<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PDF ReaderX</title>
    <!-- Tailwind CSS for modern styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f0f4f8;
            margin: 0;
            padding: 1rem;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
        }

        .controls-container {
            background-color: #ffffff;
            padding: 1.5rem;
            border-radius: 0.75rem;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
            margin-bottom: 1.5rem;
            width: 100%;
            max-width: 700px; /* Increased max-width for better voice select display */
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }

        .pdf-viewer-container {
            position: relative; /* Essential for overlaying text layer */
            width: 100%;
            max-width: 800px; /* Adjust as needed for PDF display */
            background-color: #ffffff;
            border-radius: 0.75rem;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
            overflow: hidden; /* Hide overflow from canvas and text layer */
            margin-top: 1rem;
            margin-bottom: 2rem;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 1rem; /* Padding around the PDF */
        }

        canvas {
            display: block;
            width: 100%;
            height: auto; /* Maintain aspect ratio */
            border-radius: 0.5rem;
            background-color: #e2e8f0; /* Placeholder background */
        }

        .textLayer {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            overflow: hidden;
            opacity: 0.001; /* Effectively invisible, but selectable */
            /* This opacity is crucial. Make it nearly transparent but still allow selection */
        }

        .textLayer > div {
            position: absolute;
            white-space: pre; /* Preserve whitespace */
            cursor: text; /* Indicate text is selectable */
            color: transparent; /* Make text invisible while being selectable */
            user-select: text; /* Allow text selection */
            transform-origin: 0% 0%; /* Important for text positioning */
        }

        /* Highlighting for spoken words */
        .highlighted-word {
            background-color: rgba(255, 255, 0, 0.6); /* Yellow highlight with transparency */
            border-radius: 0.2em; /* Slightly rounded corners for highlight */
            padding: 0 0.1em;
            box-decoration-break: clone; /* Ensures highlight wraps correctly over lines */
            color: black; /* Explicitly set color for visibility */
        }

        /* Highlighting for user selection */
        .user-selection-highlight {
            background-color: rgba(173, 216, 230, 0.6); /* Light blue highlight for user selection */
            border-radius: 0.2em;
            padding: 0 0.1em;
            box-decoration-break: clone;
            color: black; /* Explicitly set color for visibility */
        }

        button {
            @apply py-2 px-4 rounded-lg font-semibold shadow-md transition-all duration-200 ease-in-out;
        }
        button:hover {
            @apply transform -translate-y-0.5 shadow-lg;
        }
        button:active {
            @apply transform translate-y-0.5 shadow-md;
        }

        /* Custom styles for select element to handle long text */
        select {
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }
    </style>
</head>
<body>
    <div class="controls-container">
        <h2 class="text-2xl font-bold text-center text-gray-800 mb-2">PDF ReaderX with Read Aloud</h2>

        <div class="flex flex-col sm:flex-row items-center gap-4">
            <label for="pdfInput" class="text-sm font-medium text-gray-700 w-full sm:w-auto">Load PDF (URL):</label>
            <input type="text" id="pdfInput" value="https://raw.githubusercontent.com/mozilla/pdf.js/ba2edeae/web/compressed.tracemonkey-pldi-09.pdf"
                    class="flex-grow py-2 px-3 border border-gray-300 rounded-lg shadow-sm focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-blue-500">
            <button id="loadPdfUrlBtn" class="bg-indigo-600 text-white hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-opacity-75 w-full sm:w-auto">
                Load from URL
            </button>
        </div>

        <div class="flex flex-col sm:flex-row items-center gap-4">
            <label for="pdfFileInput" class="text-sm font-medium text-gray-700 w-full sm:w-auto">Load PDF (Local File):</label>
            <input type="file" id="pdfFileInput" accept=".pdf"
                    class="flex-grow py-2 px-3 border border-gray-300 rounded-lg shadow-sm focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-blue-500 bg-white text-gray-800">
            <button id="loadPdfFileBtn" class="bg-indigo-600 text-white hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-opacity-75 w-full sm:w-auto">
                Load from File
            </button>
        </div>

        <div class="flex flex-col sm:flex-row items-center gap-4">
            <label for="speedSelect" class="text-sm font-medium text-gray-700 w-full sm:w-auto">Reading Speed:</label>
            <select id="speedSelect" class="flex-grow py-2 px-3 border border-gray-300 rounded-lg shadow-sm focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-blue-500 bg-white text-gray-800">
                <option value="0.7">Slow</option>
                <option value="1.0" selected>Medium</option>
                <option value="1.2">Bit Faster</option>
                <option value="1.5">Fast</option>
            </select>
        </div>

        <!-- Voice Selection Control - Improved UI -->
        <div class="flex flex-col sm:flex-row items-center gap-4 p-3 bg-gray-50 rounded-lg border border-gray-200 w-full">
            <label for="voiceSelect" class="text-sm font-medium text-gray-700 sm:w-auto">Select Voice:</label>
            <select id="voiceSelect" class="flex-grow py-2 px-3 border border-gray-300 rounded-lg shadow-sm focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-blue-500 bg-white text-gray-800 min-w-0">
                <!-- Voices will be populated dynamically by JavaScript -->
                <option value="">Loading voices...</option>
            </select>
        </div>

        <!-- Go to Page and Read Current Page Controls -->
        <div class="flex flex-col sm:flex-row items-center gap-4">
            <label for="gotoPageInput" class="text-sm font-medium text-gray-700 w-full sm:w-auto">Go to Page:</label>
            <input type="number" id="gotoPageInput" value="1" min="1"
                    class="flex-grow py-2 px-3 border border-gray-300 rounded-lg shadow-sm focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-blue-500">
            <button id="gotoPageBtn" class="bg-purple-600 text-white hover:bg-purple-700 focus:outline-none focus:ring-2 focus:ring-purple-500 focus:ring-opacity-75 w-full sm:w-auto">
                Go to Page
            </button>
        </div>

        <div class="flex flex-wrap justify-center gap-3 mt-2">
            <button id="playSelectedBtn" class="bg-blue-600 text-white hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-opacity-75 flex-1 min-w-[120px]">
                Play Selection
            </button>
            <button id="readCurrentPageBtn" class="bg-teal-600 text-white hover:bg-teal-700 focus:outline-none focus:ring-2 focus:ring-teal-500 focus:ring-opacity-75 flex-1 min-w-[120px]">
                Read Current Page
            </button>
            <button id="pauseBtn" class="bg-yellow-500 text-white hover:bg-yellow-600 focus:outline-none focus:ring-2 focus:ring-yellow-400 focus:ring-opacity-75 flex-1 min-w-[120px]">
                Pause
            </button>
            <button id="resumeBtn" class="bg-green-500 text-white hover:bg-green-600 focus:outline-none focus:ring-2 focus:ring-green-400 focus:ring-opacity-75 flex-1 min-w-[120px]">
                Resume
            </button>
            <button id="stopBtn" class="bg-red-500 text-white hover:bg-red-600 focus:outline-none focus:ring-2 focus:ring-red-400 focus:ring-opacity-75 flex-1 min-w-[120px]">
                Stop
            </button>
        </div>

        <!-- Pagination Controls -->
        <div class="flex justify-center items-center gap-4 mt-4">
            <button id="prevPageBtn" class="bg-gray-400 text-white hover:bg-gray-500 focus:outline-none focus:ring-2 focus:ring-gray-300 focus:ring-opacity-75 px-3 py-1 rounded-full">
                Previous
            </button>
            <span id="pageInfo" class="text-gray-700 font-medium">Page 1 of 1</span>
            <button id="nextPageBtn" class="bg-gray-400 text-white hover:bg-gray-500 focus:outline-none focus:ring-2 focus:ring-gray-300 focus:ring-opacity-75 px-3 py-1 rounded-full">
                Next
            </button>
        </div>
        <p id="message" class="text-center text-sm text-gray-600 mt-2"></p>
    </div>

    <div class="pdf-viewer-container">
        <canvas id="pdfCanvas" class="shadow-inner"></canvas>
        <div id="textLayer" class="textLayer"></div>
    </div>

    <!-- PDF.js library from CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.worker.min.js"></script>

    <script>
        console.log("PDF Reader script loaded.");
        console.log("window.speechSynthesis:", window.speechSynthesis);

        // Set workerSrc for PDF.js
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.worker.min.js';

        const pdfCanvas = document.getElementById('pdfCanvas');
        const ctx = pdfCanvas.getContext('2d');
        const textLayerDiv = document.getElementById('textLayer');
        const pdfInput = document.getElementById('pdfInput');
        const loadPdfUrlBtn = document.getElementById('loadPdfUrlBtn');
        const pdfFileInput = document.getElementById('pdfFileInput');
        const loadPdfFileBtn = document.getElementById('loadPdfFileBtn');
        const playSelectedBtn = document.getElementById('playSelectedBtn');
        const readCurrentPageBtn = document.getElementById('readCurrentPageBtn');
        const pauseBtn = document.getElementById('pauseBtn');
        const resumeBtn = document.getElementById('resumeBtn');
        const stopBtn = document.getElementById('stopBtn');
        const speedSelect = document.getElementById('speedSelect');
        const voiceSelect = document.getElementById('voiceSelect');
        const messageDisplay = document.getElementById('message');
        const prevPageBtn = document.getElementById('prevPageBtn');
        const nextPageBtn = document.getElementById('nextPageBtn');
        const pageInfo = document.getElementById('pageInfo');
        const gotoPageInput = document.getElementById('gotoPageInput');
        const gotoPageBtn = document.getElementById('gotoPageBtn');

        let pdfDoc = null;
        let currentPageNum = 1;
        let readingSpeed = 1.0;
        let selectedVoice = null; // Will store the selected SpeechSynthesisVoice object
        let currentUtterance = null; // Stores the currently active SpeechSynthesisUtterance
        let synth = window.speechSynthesis;
        let textItems = []; // Stores text items from PDF.js
        let currentHighlightedSpans = []; // For TTS highlighting
        let currentUserSelectionHighlightSpans = []; // For user selection highlighting

        // --- Utility Functions ---
        /**
         * Displays a message to the user.
         * @param {string} msg - The message to display.
         * @param {'info' | 'error'} [type='info'] - The type of message (info or error).
         */
        function showMessage(msg, type = 'info') {
            messageDisplay.textContent = msg;
            messageDisplay.className = `text-center text-sm mt-2 ${type === 'error' ? 'text-red-600' : 'text-gray-600'}`;
        }

        /**
         * Clears the displayed message.
         */
        function clearMessage() {
            messageDisplay.textContent = '';
            messageDisplay.className = '';
        }

        /**
         * Attempts to find and return the currently selected voice object from the live voice list.
         * This is crucial to ensure we're using a valid, active voice object for utterances.
         * @returns {SpeechSynthesisVoice | null} The live SpeechSynthesisVoice object or null if not found.
         */
        function getLiveSelectedVoice() {
            if (!selectedVoice) return null; // No voice selected globally

            const voices = synth.getVoices();
            // Find the voice by its unique identifier (name and lang combination is usually robust)
            const liveVoice = voices.find(voice => 
                voice.name === selectedVoice.name && voice.lang === selectedVoice.lang
            );
            return liveVoice || null;
        }

        // --- Voice Selection ---
        /**
         * Populates the voice selection dropdown and attempts to set a preferred default voice.
         * This function prioritizes "Microsoft Andrew Online (Natural) English (United States)".
         */
        function populateVoiceList() {
            const voices = synth.getVoices().sort((a, b) => {
                const aname = a.name.toUpperCase();
                const bname = b.name.toUpperCase();
                if (aname < bname) return -1;
                if (aname > bname) return +1;
                return 0;
            });

            voiceSelect.innerHTML = ''; // Clear existing options

            let initialDefaultVoice = null;
            const preferredVoiceName = "Microsoft Andrew Online (Natural)";
            const preferredVoiceLang = "en-US"; // Use exact match for language

            // Priority 1: Try to find the exact preferred voice by name and exact language
            initialDefaultVoice = voices.find(voice => 
                voice.name === preferredVoiceName && voice.lang === preferredVoiceLang
            );

            // Priority 2: If not found, fall back to any voice that matches the preferred name, regardless of specific country code (e.g., en-GB vs en-US)
            if (!initialDefaultVoice) {
                initialDefaultVoice = voices.find(voice => voice.name === preferredVoiceName && voice.lang.startsWith('en'));
            }

            // Priority 3: If still not found, fall back to any en-US voice that isn't explicitly marked as default (to find alternatives)
            if (!initialDefaultVoice) {
                initialDefaultVoice = voices.find(voice => voice.lang === preferredVoiceLang && !voice.default);
            }

            // Priority 4: If still not found, fall back to the browser's designated default voice
            if (!initialDefaultVoice) {
                initialDefaultVoice = voices.find(voice => voice.default);
            }

            // Priority 5: Finally, if no specific default is found, pick the first available voice
            if (!initialDefaultVoice && voices.length > 0) {
                initialDefaultVoice = voices[0];
            }
            
            // Add options to the dropdown
            voices.forEach((voice) => {
                const option = document.createElement('option');
                option.textContent = `${voice.name} (${voice.lang})`;
                if (voice.default) {
                    option.textContent += ' â€” DEFAULT BROWSER VOICE'; // Clarify browser default
                }
                option.setAttribute('data-lang', voice.lang);
                option.setAttribute('data-name', voice.name);
                option.value = voice.name;
                voiceSelect.appendChild(option);
            });

            // Set the selected value in the dropdown and the global selectedVoice variable
            if (initialDefaultVoice) {
                voiceSelect.value = initialDefaultVoice.name;
                selectedVoice = initialDefaultVoice; // This is the key: update the global variable
            } else {
                voiceSelect.innerHTML = '<option value="">No voices available</option>';
                selectedVoice = null;
            }

            if (selectedVoice) {
                showMessage(`Selected voice: ${selectedVoice.name}`);
            } else {
                showMessage("No voices found. Text-to-speech may not work.", 'error');
            }
        }

        // Populate voices when they are loaded (can be asynchronous)
        synth.onvoiceschanged = populateVoiceList;

        // Initial populate in case voices are already loaded on page load
        populateVoiceList();

        // --- PDF Loading and Rendering ---
        /**
         * Loads a PDF document from a URL or ArrayBuffer.
         * @param {string | ArrayBuffer} source - The PDF URL or ArrayBuffer data.
         */
        async function loadPdf(source) {
            clearMessage();
            showMessage('Loading PDF...');
            try {
                let loadingTask;
                if (typeof source === 'string') { // Source is a URL
                    loadingTask = pdfjsLib.getDocument(source);
                } else if (source instanceof ArrayBuffer) { // Source is an ArrayBuffer (from local file)
                    loadingTask = pdfjsLib.getDocument({ data: source });
                } else {
                    throw new Error("Invalid PDF source provided. Must be a URL string or ArrayBuffer.");
                }
                
                pdfDoc = await loadingTask.promise;
                currentPageNum = 1; // Reset to first page
                pageInfo.textContent = `Page ${currentPageNum} of ${pdfDoc.numPages}`;
                gotoPageInput.max = pdfDoc.numPages; // Set max for page input
                showMessage(`PDF loaded (${pdfDoc.numPages} pages). Rendering page ${currentPageNum}...`);
                await renderPage(currentPageNum);
            } catch (error) {
                console.error("Error loading PDF:", error);
                showMessage(`Error loading PDF: ${error.message}`, 'error');
            }
        }

        /**
         * Renders a specific page of the loaded PDF.
         * @param {number} pageNum - The page number to render.
         */
        async function renderPage(pageNum) {
            if (!pdfDoc) return;

            // Stop any ongoing speech and clear highlights when changing pages
            stopSpeech();
            removeUserSelectionHighlight(); 

            // Clear previous text layer and TTS highlights
            textLayerDiv.innerHTML = '';
            currentHighlightedSpans = []; 

            try {
                const page = await pdfDoc.getPage(pageNum);
                // Adjust scale based on current container width for responsiveness
                const desiredWidth = pdfCanvas.offsetWidth; 
                const viewport = page.getViewport({ scale: desiredWidth / page.getViewport({ scale: 1 }).width });

                // Set canvas dimensions
                pdfCanvas.height = viewport.height;
                pdfCanvas.width = viewport.width;

                // Render PDF page into canvas context
                const renderContext = {
                    canvasContext: ctx,
                    viewport: viewport,
                };
                await page.render(renderContext).promise;

                // --- Render Text Layer for Selection and Highlighting ---
                const textContent = await page.getTextContent();
                textItems = textContent.items; // Store text items for highlighting logic

                // Adjust text layer dimensions to match the canvas's rendered size
                textLayerDiv.style.width = `${pdfCanvas.offsetWidth}px`;
                textLayerDiv.style.height = `${pdfCanvas.offsetHeight}px`;
                
                // Get the actual scale of the rendered PDF on the canvas relative to its original size
                // This is crucial for correctly positioning text elements
                const canvasRenderedScaleX = pdfCanvas.offsetWidth / viewport.width;
                const canvasRenderedScaleY = pdfCanvas.offsetHeight / viewport.height;
                
                textItems.forEach(item => {
                    const textDiv = document.createElement('div');
                    const { str, dir, width, height, transform } = item;

                    // Apply the PDF.js text item's transformation matrix
                    // Adjust transform values by the canvas's rendered scale to match positions
                    const [a, b, c, d, e, f] = transform;
                    textDiv.style.transform = `matrix(${a}, ${b}, ${c}, ${d}, ${e * canvasRenderedScaleX}, ${f * canvasRenderedScaleY})`;
                    
                    // Font size needs to be adjusted based on the initial viewport scale AND the canvas's final rendered scale
                    textDiv.style.fontSize = `${item.height * viewport.scale * canvasRenderedScaleY}px`;
                    textDiv.style.fontFamily = item.fontName;
                    textDiv.style.direction = dir;
                    textDiv.style.left = `${transform[4] * canvasRenderedScaleX}px`;
                    textDiv.style.top = `${transform[5] * canvasRenderedScaleY}px`;
                    textDiv.style.width = `${item.width * canvasRenderedScaleX}px`;
                    textDiv.style.height = `${item.height * canvasRenderedScaleY}px`;
                    textDiv.textContent = str;
                    textDiv.title = str; // Add title for debugging/tooltip

                    textLayerDiv.appendChild(textDiv);
                });
                currentPageNum = pageNum;
                pageInfo.textContent = `Page ${currentPageNum} of ${pdfDoc.numPages}`;
                gotoPageInput.value = currentPageNum;
                showMessage(`Page ${pageNum} rendered.`);
            } catch (error) {
                console.error("Error rendering page:", error);
                showMessage(`Error rendering page: ${error.message}`, 'error');
            }
        }

        // --- Text-to-Speech (TTS) Functions ---
        /**
         * Speaks the given text using the selected voice and speed.
         * Highlights words as they are spoken.
         * @param {string} textToSpeak - The text content to speak.
         */
        function speakText(textToSpeak) {
            if (!synth) {
                showMessage("SpeechSynthesis not supported in this browser.", 'error');
                return;
            }
            const liveVoice = getLiveSelectedVoice(); // Get the live voice object
            if (!liveVoice) {
                showMessage("Selected voice not found or not available. Please choose another voice.", 'error');
                return;
            }

            // Cancel any ongoing speech before starting a new one
            if (currentUtterance && synth.speaking) {
                synth.cancel();
            }

            currentUtterance = new SpeechSynthesisUtterance(textToSpeak);
            currentUtterance.rate = readingSpeed;
            currentUtterance.voice = liveVoice; // Crucially, use the live voice object
            console.log(`[speakText] Using voice: ${currentUtterance.voice ? currentUtterance.voice.name : 'None'}`);


            currentUtterance.onboundary = (event) => {
                if (event.name === 'word') {
                    highlightWord(event.charIndex, event.charLength, currentUtterance.text);
                }
            };

            currentUtterance.onend = () => {
                removeHighlights();
                currentUtterance = null;
                showMessage("Reading finished.");
            };

            currentUtterance.onerror = (event) => {
                console.error("SpeechSynthesisUtterance error:", event.error);
                removeHighlights();
                currentUtterance = null;
                showMessage(`Reading error: ${event.error}`, 'error');
            };

            synth.speak(currentUtterance);
            showMessage(`Reading selected text...`);
        }

        /**
         * Pauses the current speech synthesis.
         */
        function pauseSpeech() {
            if (synth && synth.speaking && !synth.paused) {
                synth.pause();
                showMessage("Reading paused.");
            } else if (synth && synth.paused) {
                showMessage("Speech is already paused.");
            } else {
                showMessage("No active speech to pause.");
            }
        }

        /**
         * Resumes the paused speech synthesis.
         */
        function resumeSpeech() {
            if (synth && synth.paused) {
                synth.resume();
                showMessage("Resuming reading.");
            } else if (synth && synth.speaking) {
                showMessage("Speech is already playing.");
            } else {
                showMessage("No paused speech to resume.");
            }
        }

        /**
         * Stops the current speech synthesis and clears highlights.
         */
        function stopSpeech() {
            console.log("Attempting to stop speech.");
            if (synth) {
                if (synth.speaking || synth.paused) {
                    synth.cancel();
                    console.log("Speech cancelled by stopSpeech.");
                } else {
                    console.log("No active speech to stop.");
                }
            } else {
                console.warn("SpeechSynthesis API not available in stopSpeech.");
            }
            removeHighlights();
            currentUtterance = null;
            showMessage("Reading stopped.");
        }

        /**
         * Reads the full text content of the current PDF page.
         * Automatically advances to the next page upon completion.
         */
        async function readFullPage() {
            if (!pdfDoc) {
                showMessage("No PDF loaded.", 'error');
                return;
            }
            stopSpeech(); // Stop any ongoing speech
            removeUserSelectionHighlight(); // Clear any existing user selection highlight

            let fullPageText = "";
            const textDivs = Array.from(textLayerDiv.children);
            // Concatenate text content from all text layer divs, adding a space between them
            // to simulate natural reading flow.
            textDivs.forEach((div, index) => {
                fullPageText += div.textContent;
                if (index < textDivs.length - 1) {
                    fullPageText += " "; // Add a space between text blocks
                }
            });

            if (fullPageText.length > 0) {
                const utterance = new SpeechSynthesisUtterance(fullPageText);
                utterance.rate = readingSpeed;
                
                const liveVoice = getLiveSelectedVoice(); // Get the live voice object
                if (liveVoice) {
                    utterance.voice = liveVoice; // Set the selected live voice
                } else {
                    showMessage("Selected voice not found or not available. Using browser default.", 'info');
                    // As a final fallback, try to find *any* default voice if the selected one isn't available
                    const defaultVoice = synth.getVoices().find(voice => voice.default || voice.lang.startsWith('en'));
                    if (defaultVoice) {
                        utterance.voice = defaultVoice;
                    } else {
                        showMessage("No voices found to read the page.", 'error');
                        return; // Cannot read without a voice
                    }
                }
                currentUtterance = utterance;
                console.log(`[readFullPage] Using voice: ${currentUtterance.voice ? currentUtterance.voice.name : 'None'} for page ${currentPageNum}`);


                utterance.onboundary = (event) => {
                    // Highlight words as they are spoken
                    if (event.name === 'word') {
                        highlightWord(event.charIndex, event.charLength, utterance.text);
                    }
                };

                utterance.onend = async () => {
                    removeHighlights();
                    currentUtterance = null;
                    showMessage("Page reading finished. Checking for next page...");
                    // If there are more pages, render the next one and continue reading
                    if (pdfDoc && currentPageNum < pdfDoc.numPages) {
                        currentPageNum++;
                        await renderPage(currentPageNum);
                        readFullPage(); // Recursively call to read the next page
                    } else {
                        showMessage("Finished reading the entire document.");
                    }
                };

                utterance.onerror = (event) => {
                    console.error("SpeechSynthesisUtterance error:", event.error);
                    removeHighlights();
                    currentUtterance = null;
                    showMessage(`Reading error: ${event.error}`, 'error');
                };

                synth.speak(utterance);
                showMessage(`Reading current page... Page ${currentPageNum} of ${pdfDoc.numPages}`);
            } else {
                showMessage("No text found on current page to read. Checking for next page...", 'info');
                // If current page has no text, try to advance to the next page automatically
                if (pdfDoc && currentPageNum < pdfDoc.numPages) {
                    currentPageNum++;
                    await renderPage(currentPageNum);
                    readFullPage(); // Recursively call to read the next page
                } else {
                    showMessage("Finished reading the entire document.");
                }
            }
        }

        // --- Highlighting Functions for TTS ---
        /**
         * Highlights the currently spoken word in the text layer.
         * This function attempts to find the word's position within the displayed text divs.
         * @param {number} charIndexInUtterance - The starting character index of the word within the full spoken text.
         * @param {number} charLength - The length of the spoken word.
         * @param {string} spokenText - The full text being spoken by the utterance.
         */
        function highlightWord(charIndexInUtterance, charLength, spokenText) {
            console.log(`highlightWord called: index=${charIndexInUtterance}, length=${charLength}, word="${spokenText.substring(charIndexInUtterance, charIndexInUtterance + charLength)}"`);
            removeHighlights(); // Ensure previous TTS highlights are removed

            const spokenWord = spokenText.substring(charIndexInUtterance, charIndexInUtterance + charLength);
            const textDivs = Array.from(textLayerDiv.children);
            let currentGlobalCharOffset = 0; // Tracks character offset across concatenated text divs

            // Iterate through each text div to find where the spoken word is located
            for (const textDiv of textDivs) {
                const divText = textDiv.textContent;

                // Determine the start index within the current div where the spoken word *could* begin.
                // This accounts for the accumulating character offset from previous divs.
                const searchStartIndexInDiv = Math.max(0, charIndexInUtterance - currentGlobalCharOffset);
                const matchIndexInDiv = divText.indexOf(spokenWord, searchStartIndexInDiv);
                
                // Verify that the found match corresponds to the current word boundary event's global position.
                // This is important to ensure we highlight the correct instance of a word if it appears multiple times.
                const globalMatchStart = currentGlobalCharOffset + matchIndexInDiv;
                const globalMatchEnd = globalMatchStart + spokenWord.length; 

                // Check if the word was found in this div and if its global position matches the utterance event
                if (matchIndexInDiv !== -1 && charIndexInUtterance >= globalMatchStart && charIndexInUtterance < globalMatchEnd) {
                    console.log(`  Found potential match in div: "${divText.substring(matchIndexInDiv, matchIndexInDiv + spokenWord.length)}"`);
                    let currentTextNodeCharOffset = 0; // Tracks character offset within the current div's text nodes

                    // Iterate through the text nodes within the current div to find the precise text node
                    for (const node of textDiv.childNodes) {
                        if (node.nodeType === Node.TEXT_NODE) {
                            const nodeTextContent = node.textContent;

                            // Check if the word starts within this text node
                            if (matchIndexInDiv >= currentTextNodeCharOffset && 
                                matchIndexInDiv < currentTextNodeCharOffset + nodeTextContent.length) {
                                
                                const relativeStartInNode = matchIndexInDiv - currentTextNodeCharOffset;
                                const relativeEndInNode = relativeStartInNode + charLength;

                                // Ensure the entire word is contained within this single text node
                                if (relativeEndInNode <= nodeTextContent.length) {
                                    const range = document.createRange();
                                    range.setStart(node, relativeStartInNode);
                                    range.setEnd(node, relativeEndInNode);

                                    const span = document.createElement('span');
                                    span.className = 'highlighted-word';
                                    try {
                                        // Surround the matched word with a span for highlighting
                                        range.surroundContents(span);
                                        currentHighlightedSpans.push(span);
                                        console.log("  Applied precise highlight to span.");
                                        return; // Word highlighted, exit function immediately
                                    } catch (e) {
                                        // If surrounding fails (e.g., due to existing complex DOM structure), log warning
                                        console.warn("  SurroundContents failed on specific text node. Trying fallback.", e);
                                        break; // Break inner loop, will fall through to highlight the whole div as fallback
                                    }
                                }
                            }
                            currentTextNodeCharOffset += nodeTextContent.length;
                        }
                    }
                    // Fallback: If precise text node highlighting failed or the word spans multiple nodes,
                    // highlight the entire containing div.
                    textDiv.classList.add('highlighted-word');
                    currentHighlightedSpans.push(textDiv);
                    console.log("  Applied fallback highlight to div.");
                    return; // Word handled, exit function
                }
                // Account for the length of the current div's text and the space added between divs for speech
                currentGlobalCharOffset += divText.length; 
                if (textDivs.indexOf(textDiv) < textDivs.length - 1) { // If it's not the last div
                    currentGlobalCharOffset += 1; // Account for the space we added between divs
                }
            }
            console.log("  No highlight applied for word: " + spokenWord);
        }

        /**
         * Removes all active TTS highlighting spans.
         */
        function removeHighlights() {
            console.log("Removing TTS highlights. Spans to remove:", currentHighlightedSpans.length);
            currentHighlightedSpans.forEach(el => {
                if (el.parentNode) {
                    // If it's a span we created, unwrap its content and remove the span
                    if (el.classList.contains('highlighted-word') && el.nodeName === 'SPAN') {
                        while (el.firstChild) {
                            el.parentNode.insertBefore(el.firstChild, el);
                        }
                        el.parentNode.removeChild(el);
                    } else if (el.classList.contains('highlighted-word')) { 
                        // If it's a div (fallback highlight), just remove the class
                        el.classList.remove('highlighted-word');
                    }
                }
            });
            currentHighlightedSpans = []; // Clear the array
        }

        // --- Highlighting Functions for User Selection ---
        /**
         * Applies a highlight to the user's current text selection within the text layer.
         * Clears any previous user selection highlights and active TTS highlights.
         */
        function applyUserSelectionHighlight() {
            console.log("Applying user selection highlight.");
            removeUserSelectionHighlight(); // Clear previous user selection highlight
            removeHighlights(); // Clear any active TTS highlight (important to avoid conflicts)

            const selection = window.getSelection();
            const selectedTextContent = selection.toString(); // Get current selection text
            
            if (selection.rangeCount > 0 && selectedTextContent.length > 0) {
                const originalRange = selection.getRangeAt(0);
                const textDivs = Array.from(textLayerDiv.children);

                // Iterate through text divs to apply highlight to intersecting parts
                textDivs.forEach(textDiv => {
                    // Check if the textDiv node actually contains any part of the selection
                    if (originalRange.intersectsNode(textDiv)) {
                        for (const node of textDiv.childNodes) {
                            if (node.nodeType === Node.TEXT_NODE) {
                                const nodeTextContent = node.textContent;
                                const nodeRange = document.createRange();
                                nodeRange.selectNodeContents(node);

                                // Check if the current text node intersects with the user's selection
                                if (originalRange.compareBoundaryPoints(Range.END_TO_START, nodeRange) < 0 &&
                                    originalRange.compareBoundaryPoints(Range.START_TO_END, nodeRange) > 0) {
                                    
                                    // Create a temporary range for the intersection within this text node
                                    const intersectionRange = document.createRange();
                                    
                                    // Set intersection start point
                                    if (originalRange.startContainer === node) {
                                        intersectionRange.setStart(node, originalRange.startOffset);
                                    } else {
                                        // If selection starts before this node, the intersection starts at the beginning of this node
                                        intersectionRange.setStart(node, 0); 
                                    }

                                    // Set intersection end point
                                    if (originalRange.endContainer === node) {
                                        intersectionRange.setEnd(node, originalRange.endOffset);
                                    } else {
                                        // If selection ends after this node, the intersection ends at the end of this node
                                        intersectionRange.setEnd(node, nodeTextContent.length); 
                                    }

                                    // Check if the intersection range is valid and has content
                                    if (intersectionRange.toString().length > 0 && intersectionRange.collapsed === false) {
                                        const span = document.createElement('span');
                                        span.className = 'user-selection-highlight';
                                        try {
                                            // Surround the intersecting part within this specific text node
                                            intersectionRange.surroundContents(span);
                                            currentUserSelectionHighlightSpans.push(span);
                                            console.log("  Applied precise user selection highlight to span:", span.textContent);
                                        } catch (e) {
                                            console.warn("  SurroundContents failed for user selection on text node. Fallback to div class.", e);
                                            // Fallback to highlighting the entire div if precise wrapping fails
                                            textDiv.classList.add('user-selection-highlight');
                                            currentUserSelectionHighlightSpans.push(textDiv);
                                            // Break from inner loop as we've handled highlighting for this div
                                            break; 
                                        }
                                    }
                                }
                            }
                        }
                    }
                });
                if (currentUserSelectionHighlightSpans.length === 0 && selectedTextContent.length > 0) {
                    console.warn("No precise user selection highlights applied via spans. Browser's native selection might still be visible.");
                }

            } else {
                console.log("No selection to highlight.");
            }
        }

        /**
         * Removes all active user selection highlighting spans.
         */
        function removeUserSelectionHighlight() {
            console.log("Removing user selection highlights. Spans to remove:", currentUserSelectionHighlightSpans.length);
            currentUserSelectionHighlightSpans.forEach(el => {
                if (el.parentNode) {
                    // If it's a span we created, unwrap its content and remove the span
                    if (el.classList.contains('user-selection-highlight') && el.nodeName === 'SPAN') {
                        while (el.firstChild) {
                            el.parentNode.insertBefore(el.firstChild, el);
                        }
                        el.parentNode.removeChild(el);
                    } else if (el.classList.contains('user-selection-highlight')) { 
                        // If it's a div (fallback highlight), just remove the class
                        el.classList.remove('user-selection-highlight');
                    }
                }
            });
            currentUserSelectionHighlightSpans = []; // Clear the array
        }

        // --- Event Listeners ---
        loadPdfUrlBtn.addEventListener('click', () => {
            const url = pdfInput.value.trim();
            if (url) {
                loadPdf(url);
            } else {
                showMessage("Please enter a PDF URL.", 'error');
            }
        });

        loadPdfFileBtn.addEventListener('click', () => {
            const file = pdfFileInput.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = (e) => {
                    loadPdf(e.target.result);
                };
                reader.onerror = (e) => {
                    console.error("Error reading file:", e);
                    showMessage(`Error reading file: ${e.message}`, 'error');
                };
                reader.readAsArrayBuffer(file);
            } else {
                showMessage("Please select a local PDF file.", 'error');
            }
        });

        gotoPageBtn.addEventListener('click', () => {
            if (!pdfDoc) {
                showMessage("Please load a PDF first.", 'error');
                return;
            }
            const pageNum = parseInt(gotoPageInput.value, 10);
            if (isNaN(pageNum) || pageNum < 1 || pageNum > pdfDoc.numPages) {
                showMessage(`Please enter a valid page number between 1 and ${pdfDoc.numPages}.`, 'error');
                return;
            }
            renderPage(pageNum);
        });

        readCurrentPageBtn.addEventListener('click', readFullPage);

        playSelectedBtn.addEventListener('click', () => {
            stopSpeech(); // Stop any ongoing speech
            removeUserSelectionHighlight(); // Always clear user selection highlight before speaking

            const selection = window.getSelection();
            const selectedTextContent = selection.toString().trim();

            if (selectedTextContent.length === 0) {
                showMessage("Please select some text to read aloud.", 'info');
                return;
            }
            console.log("Selected text for playback:", selectedTextContent);

            // Get all text content from the current page's text layer divs
            let fullPageText = "";
            const textDivs = Array.from(textLayerDiv.children);
            textDivs.forEach((div, index) => {
                fullPageText += div.textContent;
                // Add a space between div contents to reflect natural reading flow,
                // and to match how SpeechSynthesisUtterance might segment text.
                if (index < textDivs.length - 1) {
                    fullPageText += " ";
                }
            });
            console.log("Full page text extracted (start):", fullPageText.substring(0, Math.min(fullPageText.length, 100)) + "..."); // Log a snippet

            // Find the starting position of the selection within the full page text.
            const selectionStartIndexInPage = fullPageText.indexOf(selectedTextContent);
            console.log("Selection start index in page text:", selectionStartIndexInPage);

            let textToRead = "";
            if (selectionStartIndexInPage !== -1) {
                // If the selected text is found, read from that point onwards in the full page text.
                textToRead = fullPageText.substring(selectionStartIndexInPage);
            } else {
                // Fallback: If for some reason the selected text isn't found contiguously
                // in the reconstructed fullPageText (e.g., due to line breaks, complex spacing),
                // just speak the raw selected content. Highlighting might be less accurate in this case.
                console.warn("Selected text not found contiguously in page text. Speaking raw selection.");
                textToRead = selectedTextContent;
            }

            if (textToRead.length > 0) {
                console.log("Text to send to speakText (start):", textToRead.substring(0, Math.min(textToRead.length, 100)) + "...");
                speakText(textToRead);
            } else {
                showMessage("Could not extract text for reading. Please try selecting again.", 'error');
            }
        });

        // Listen for mouseup events on the text layer to apply user selection highlight
        textLayerDiv.addEventListener('mouseup', applyUserSelectionHighlight);
        // Also listen for keyup, especially for keyboard selections (Shift + arrow keys)
        textLayerDiv.addEventListener('keyup', (event) => {
            if (event.shiftKey || event.key.startsWith('Arrow')) {
                applyUserSelectionHighlight();
            }
        });

        // Listen for selection changes globally
        document.addEventListener('selectionchange', () => {
            const selection = window.getSelection();
            if (selection.rangeCount > 0 && selection.toString().length > 0) {
                const range = selection.getRangeAt(0);
                // Check if the selection is within our textLayerDiv by checking common ancestor or start/end containers
                if (textLayerDiv.contains(range.commonAncestorContainer) || 
                    (range.startContainer && textLayerDiv.contains(range.startContainer)) ||
                    (range.endContainer && textLayerDiv.contains(range.endContainer))) {
                    applyUserSelectionHighlight();
                } else {
                    removeUserSelectionHighlight(); // Clear if selection moves outside our text layer
                }
            } else {
                removeUserSelectionHighlight(); // Clear if selection is empty
            }
        });


        pauseBtn.addEventListener('click', pauseSpeech);
        resumeBtn.addEventListener('click', resumeSpeech);
        stopBtn.addEventListener('click', stopSpeech);

        speedSelect.addEventListener('change', (event) => {
            readingSpeed = parseFloat(event.target.value);
            if (currentUtterance) {
                currentUtterance.rate = readingSpeed;
            }
            showMessage(`Reading speed set to ${readingSpeed}x.`);
        });
        
        voiceSelect.addEventListener('change', (event) => {
            const selectedVoiceName = event.target.value;
            const voices = synth.getVoices(); // Re-fetch voices to ensure freshness
            selectedVoice = voices.find(voice => voice.name === selectedVoiceName) || null;
            if (selectedVoice) {
                showMessage(`Voice set to: ${selectedVoice.name}`);
            } else {
                showMessage("Selected voice not found.", 'error');
            }
            // If there's an active utterance, update its voice immediately
            // This allows changing the voice mid-speak
            if (currentUtterance) {
                const liveVoice = getLiveSelectedVoice();
                if (liveVoice) {
                    currentUtterance.voice = liveVoice;
                } else {
                    console.warn("Could not find live voice for active utterance after selection change.");
                }
            }
        });


        prevPageBtn.addEventListener('click', () => {
            if (pdfDoc && currentPageNum > 1) {
                currentPageNum--;
                renderPage(currentPageNum);
            } else {
                showMessage("Already on the first page.", 'info');
            }
        });

        nextPageBtn.addEventListener('click', () => {
            if (pdfDoc && currentPageNum < pdfDoc.numPages) {
                currentPageNum++;
                renderPage(currentPageNum);
            } else {
                showMessage("Already on the last page.", 'info');
            }
        });

        // Initial PDF load when the window loads
        window.onload = function() {
            loadPdf(pdfInput.value);
        };

        // Re-render the page on window resize to ensure responsiveness of PDF and text layer
        window.addEventListener('resize', () => {
            if (pdfDoc) {
                renderPage(currentPageNum);
            }
        });
    </script>
</body>
</html>
